require "open3"

require "redmine_text_format_converter/base"

module RedmineTextFormatConverter
  class Checker < Base
    def run
      invalid_attributes = []
      TEXT_ATTRIBUTES.each do |klass, text_attribute_name|
        text_getter_name = text_attribute_name
        relation = klass.where("#{text_attribute_name} != ''")
        n = relation.count
        puts("#{klass.name}##{text_attribute_name} #{n} rows:")
        display_progress_bar("checking", n) do |progress|
          relation.order(:id).each_with_index do |o, i|
            l.debug { "checking: i=<#{i}> id=<#{o.id}>" }
            original_text = o.send(text_getter_name)
            invalid_attribute = check_text(o, text_attribute_name, original_text)
            invalid_attributes << invalid_attribute if invalid_attribute
            progress.inc
          end
        end
      end
      if invalid_attributes.length <= 0
        puts("Yay! No invalid attributes.")
      else
        puts("#{invalid_attributes.length} invalid attributes are found.")
        File.write("invalid_attributes.yml", <<EOS.chomp)
# This file is generated by "redmine:check_texts" task.

#{invalid_attributes.to_yaml}
EOS
      end
    end

    private

    def check_text(record, text_attribute_name, text)
      invalid_attribute = nil
      n_pre_begin_tags = text.each_line.lazy.grep(/<pre>/).count
      n_pre_end_tags = text.each_line.lazy.grep(%r|</pre>|).count
      if n_pre_begin_tags != n_pre_end_tags
        reason = "mismatch number of <pre>(#{n_pre_begin_tags})" +
          " and </pre>(#{n_pre_end_tags})"
        invalid_attribute = {
          klass: record.class.name,
          text_attribute_name: text_attribute_name.to_s,
          id: record.id,
          reason: reason,
        }
        l.warn {
          "#{create_location_string(invalid_attribute)}: #{reason}"
        }
      end
      return invalid_attribute
    end
  end
end
